#!/usr/bin/env ruby
# frozen_string_literal: true

require "json"
# rubocop:disable Style/GlobalVars

$github_token = ARGV[0]
$since_sha = ARGV[1] || "HEAD~5"

if $github_token.nil? || $github_token == "--help"
  puts <<~HELP
    Decidim's changelog generator.

    ## Example

        bin/changelog_generator <GITHUB PERSONAL ACCESS TOKEN> <SHA>

    ## Params

    The <GITHUB PERSONAL ACCESS TOKEN> can be obtained from https://github.com/settings/tokens/new
    You'll need to create one with `public_repo` access.

    The <SHA> is the git commit SHA from which to consider the changes. It's
    usually the last commit that modified the `.decidim_version` file.

    ## Explanation

    This script will generate the sections needed for the changelog, using the
    labels of the merged PRs as a source of truth. It will add a section at the
    end, "Unsorted", with the list of PRs that couldn't be classified.

    It ignores any Crowdin PR.
  HELP

  exit 1
end
list_of_commits = `git log #{$since_sha}..HEAD --pretty=format:"%s"`.split("\n").reverse

$github_token = ARGV[0]

def crowdin?(commit)
  !commit.match(/New Crowdin updates/).nil?
end

def get_pr_id(commit)
  commit.scan(/\d+/).last
end

def get_pr_data(commit)
  id = get_pr_id(commit)
  return nil unless id

  data = get_data_for_pr(id)
  labels = data["labels"].map { |l| l["name"] }.sort
  title = data["title"]

  {
    id: id,
    title: title,
    labels: labels,
    type: labels.select { |l| l.match(/^type: /) || l == "target: developer-experience" },
    modules: labels.select { |l| l.match(/^module: /) }
  }
end

def get_data_for_pr(id)
  uri = "https://api.github.com/repos/decidim/decidim/issues/#{id}"
  response = `curl -s -H "Authorization: token #{$github_token}" "#{uri}"`
  JSON.parse(response)
end

handled_ids = []

prs = list_of_commits.inject({}) do |acc, commit|
  next acc if crowdin?(commit)

  acc.update(commit => get_pr_data(commit))
end

types = {
  "Added" => {
    label: "type: feature",
    skip_modules: false
  },
  "Changed" => {
    label: "type: change",
    skip_modules: false
  },
  "Fixed" => {
    label: "type: fix",
    skip_modules: false
  },
  "Removed" => {
    label: "type: removal",
    skip_modules: false
  },
  "Developer improvements" => {
    label: "target: developer-experience",
    skip_modules: true
  }
}

types.each do |type_title, type_data|
  type_prs = prs.select do |_commit_title, data|
    next unless data

    data[:type].include?(type_data[:label])
  end

  puts "### #{type_title}\n"
  puts "\n"

  if type_prs.any?
    type_prs.each do |_pr_title, data|
      modules_list = data[:modules].map { |l| "**decidim-#{l.delete_prefix("module: ")}**" }
      id = data[:id]
      title = data[:title]

      handled_ids << id

      # We need to do this so that it generates the expected Markdown format.
      # String interpolation messes with the format.
      pr_link = "[#{"\\#" + id.to_s}](https://github.com/decidim/decidim/pull/#{id})" # rubocop:disable Style/StringConcatenation

      if type_data[:skip_modules]
        puts "- #{title} #{pr_link}\n"
      else
        puts "- #{modules_list.join(", ")}: #{title} #{pr_link}\n"
      end
    end
  else
    puts "Nothing.\n"
  end

  puts "\n"
end

unsorted_prs = prs.reject do |_commit_title, data|
  pr_data = data || {}

  handled_ids.include?(pr_data[:id])
end

if unsorted_prs.any?
  puts "### Unsorted\n"
  puts "\n"

  unsorted_prs.map do |title, data|
    puts "- #{title} || #{data}\n"
  end
end
# rubocop:enable Style/GlobalVars
