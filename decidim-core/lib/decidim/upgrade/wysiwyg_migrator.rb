# frozen_string_literal: true

module Decidim
  module Upgrade
    class WysiwygMigrator
      class << self
        def convert(content)
          new(content).run
        end
      end

      def initialize(content)
        @doc = Nokogiri::HTML5.parse("")
        @content = content
      end

      def run
        content_doc = Nokogiri::HTML5.parse(content)
        content_root = content_doc.at("//body")
        return content if content_root.children.empty?
        return content if content_root.children.length == 1 && content_root.children.first.name == "text"

        root = doc.at("//body")
        content_root.children.each do |node|
          append_node(root, convert_node(node))
        end
        root.inner_html
      end

      private

      attr_reader :doc, :content

      def append_node(parent, node)
        if node.is_a?(Array)
          node.each { |sub| append_node(parent, sub) }
        else
          parent.add_child node
        end
      end

      def convert_node(node)
        case node.name
        when "p"
          convert_paragraph(node)
        when "img"
          convert_image(node)
        when "ul", "ol"
          convert_list(node)
        when "iframe"
          convert_iframe(node)
        when "blockquote"
          convert_blockquote(node)
        when "code"
          convert_code(node)
        else
          node
        end
      end

      def convert_paragraph(paragraph)
        result = []
        parent = Nokogiri::XML::Node.new(paragraph.name, doc)

        indent = detect_indent(paragraph)
        parent.add_class("editor-indent-#{indent}") if indent.positive?

        paragraph.children.each do |child|
          case child.name
          when "img", "code"
            if parent.children.any?
              result.push(parent)
              parent = Nokogiri::XML::Node.new(paragraph.name, doc)
            end

            result.push convert_node(child)
          else
            parent.add_child convert_node(child)
          end
        end

        result.push(parent) if parent.children.any?

        result
      end

      # Images with the new editor are wrapped in a wrapper div as follows:
      #   <div class="editor-content-image" data-image="">
      #     <img src="..." alt="">
      #   </div>
      #
      # We are also setting an empty `alt` attribute on the image tag to make it
      # consistent as the new editor allows defining the `alt` attributes.
      def convert_image(image)
        parent = Nokogiri::XML::Node.new("div", doc)
        parent.add_class("editor-content-image")
        parent.set_attribute("data-image", "")
        image.set_attribute("alt", "") if image["alt"].nil?
        parent.add_child(image)
        parent
      end

      # Quill.js did not support multi-level lists which is why it used a CSS
      # hack to make it visually look like the list has multiple levels. This
      # is not semantically correct but for users with no visual impairments it
      # worked fine.
      #
      # The list HTML generated by Quill.js looks as follows:
      #   <ul>
      #     <li>Level 1 - Item 1</li>
      #     <li class="ql-indent-1">Level 2 - Item 1</li>
      #     <li class="ql-indent-2">Level 3 - Item 1</li>
      #     <li class="ql-indent-3">Level 4 - Item 1</li>
      #     <li class="ql-indent-2">Level 3 - Item 2</li>
      #     <li class="ql-indent-1">Level 2 - Item 2</li>
      #     <li>Level 1 - Item 2</li>
      #     <li>Level 1 - Item 3</li>
      #   </ul>
      #
      # The correct structure for this with the TipTap editor is as follows:
      #   <ul>
      #     <li>
      #       <p>Level 1 - Item 1</p>
      #       <ul>
      #         <li>
      #           <p>Level 2 - Item 1</p>
      #            <ul>
      #              <li>
      #                <p>Level 3 - Item 1</p>
      #                <ul>
      #                   <li><p>Level 4 - Item 1</p></li>
      #                </ul>
      #              </li>
      #              <li><p>Level 3 - Item 2</p></li>
      #            </ul>
      #         </li>
      #         <li><p>Level 2 - Item 2</p></li>
      #       </ul>
      #     </li>
      #     <li><p>Level 1 - Item 2</p></li>
      #     <li><p>Level 1 - Item 3</p></li>
      #   </ul>
      #
      # Note that the `<p>` elements are not necessary in HTML but TipTap
      # requires them in order to make it possible to style the content within
      # the list elements.
      def convert_list(list)
        parent = Nokogiri::XML::Node.new(list.name, doc)

        create_item = lambda do
          li = Nokogiri::XML::Node.new("li", doc)
          paragraph = Nokogiri::XML::Node.new("p", doc)
          li.add_child(paragraph)
          [li, paragraph]
        end
        add_empty_child = lambda do |child_parent|
          li, paragraph = create_item.call
          child_parent.add_child(li)
          [li, paragraph]
        end

        li = paragraph = nil
        current_parent = parent
        current_level = 0
        list.children.each do |item|
          indent = detect_indent(item)
          if indent == current_level || li.nil?
            if item.child.name == "p"
              # This content has already been migrated so we do not need to
              # re-migrate it.
              append_node(current_parent, convert_node(item))
              next
            else
              li, paragraph = add_empty_child.call(current_parent)
            end
          end

          while indent > current_level
            sublist = Nokogiri::XML::Node.new(list.name, doc)
            li.add_child(sublist)
            li, paragraph = create_item.call
            sublist.add_child(li)

            current_level += 1
            current_parent = sublist
          end
          while indent < current_level
            current_level -= 1
            li = current_parent.parent
            current_parent = li.parent
            paragraph = li.child

            li, paragraph = add_empty_child.call(current_parent) if indent == current_level
          end

          item.children.each { |child| append_node(paragraph, convert_node(child)) }
        end

        parent
      end

      # Converts iframe embeds to the new format. We assume all iframes are
      # video embeds as this the only type of embed what Quill.js supported and
      # also the only type we support in TipTap when this migration was written.
      #
      # Old format:
      #   <iframe src="https://www.youtube.com/embed/f6JMgJAQ2tc?showinfo=0" title="Decidim" frameborder="0" allowfullscreen="true"></iframe>
      #
      # New format:
      #   <div class="editor-content-videoEmbed" data-video-embed="https://www.youtube.com/embed/f6JMgJAQ2tc?showinfo=0">
      #     <div>
      #       <iframe src="https://www.youtube.com/embed/f6JMgJAQ2tc?showinfo=0" title="Decidim" frameborder="0" allowfullscreen="true"></iframe>
      #     </div>
      #   </div>
      def convert_iframe(node)
        src = node["src"]
        title = node["title"]

        parent = Nokogiri::XML::Node.new("div", doc)
        parent.add_class("editor-content-videoEmbed")
        parent.set_attribute("data-video-embed", src)

        wrapper = Nokogiri::XML::Node.new("div", doc)
        parent.add_child(wrapper)

        iframe = Nokogiri::XML::Node.new(node.name, doc)
        iframe.set_attribute("src", src)
        iframe.set_attribute("title", title || "")
        iframe.set_attribute("frameborder", "0")
        iframe.set_attribute("allowfullscreen", "true")
        wrapper.add_child(iframe)

        parent
      end

      # Blockquotes have block level content, i.e. the content needs to be
      # wrapped in a `<p>` tag. In Quill.js the content used to be directly
      # inside the `<blockquote>` element.
      def convert_blockquote(node)
        # In case the node already contains a `<p>` element, it has been
        # migrated.
        return node if node.child.name == "p"

        parent = Nokogiri::XML::Node.new(node.name, doc)
        paragraph = Nokogiri::XML::Node.new("p", doc)
        parent.add_child(paragraph)

        node.children.each { |child| append_node(paragraph, convert_node(child)) }

        parent
      end

      # The code blocks are wrapped in a `<pre>` tag and we also add the
      # "code-block" class to the code element in order to display it correctly.
      #
      # The end result should look as follows:
      #   <pre>
      #     <code class="code-block">{"foo": "bar"}</code>
      #   </pre>
      def convert_code(node)
        parent = Nokogiri::XML::Node.new("pre", doc)
        parent.add_child(node)
        node.add_class("code-block")

        parent
      end

      def detect_indent(node)
        node["class"]&.match(/^(ql|editor)-indent-([0-9]+)/)&.public_send(:[], 2).to_i
      end
    end
  end
end
